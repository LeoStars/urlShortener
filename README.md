# urlShortener

ВНИМАНИЕ! Информация для разработчиков из Avito, которые будут проверять это задание. Это новая версия (я начал изучать SQL) приложения. Старая версия, которую я прикрепил к заявке, тут: https://github.com/LeoStars/urlShortenerJSON. Они отличаются разным подходом и разными БД.

## Краткое описание работы:

В качестве БД используется PostreSQL=база данных, в котором каждый элемент содержит в себе поля ID, address и short (идентификатор в БД, адрес исходный и адрес сокращённый).

1. Чтобы запустить проект, необходимо прописать в той же папке, что и main.go, [`go run .`]
2. Далее в зависимости от того, что нам необходимо:

- 1 - Декодировать введённый нами URL адрес по алгоритму base62, который будет описан ниже. Например, из [google.com](google.com) в [`localhost:8080/c`], где [`c`] - сокращённая ссылка. Для этого в командной строке пишем: [`curl -X POST -d *JSON-структура* http://localhost:8080/decode`]. Например, [`curl -X POST -d "{\"address\": \"www.google.com\"}" http://localhost:8080/decode`].
- 2 - Создать короткую ссылку вида, которого мы захотим. Например, из [google.com](google.com) в [`localhost:8080/the-most-popular-search`], где [`the-most-popular-search`] - сокращённая (нет:)) ссылка, придуманная нами. Для этого в командной строке пишем: [`curl -X POST -d *JSON-структура* http://localhost:8080/custom`]. Например, [`curl -X POST -d "{\"address\": \"vk.com\", \"short\": \"tellmeabout\"}" http://localhost:8080/custom`]
- 3 - Redirect - перенаправление с введённого нами сокращённого адреса на исходный, если он есть в базе. Если нет, то будет "страница недоступна", а сайт не откроется. Чтобы осуществить переход, нужно в строке браузера ввести [`localhost:8080/*сокращённая-ссылка*`] (при запущенном коде и выбранном пункте Redirect!). Либо в командной строке прописать [`curl -i localhost:8080/*сокращенная ссылка*`]. К примеру, [`curl -i localhost:9090/the-most-popular-search`].

## Подробное описание работы

### /decode

Берём структуру с исходным адресом из командной строки, расшифровываем её с помощью создания Decoder'а и проверяем, правильно ли расшифровались данные. Затем начинаем процедуру добавления адреса к базе данных. К полученному после расшифровки адресу начинаем применять алгоритм шифрования base62:

1. Создаём словарь,  в котором представлено 62 ключа и, значит, 62 элемента для шифрования. Каждый элемент словаря - это символ из последовательности [a..z, A..Z, 0..9]. Каждый ключ - это число от 0 до 62.
2. При занесении в БД мы берём следующий идентификатор после последнего в предыдущей версии БД. Например, последний адрес в БД сейчас под ID == 54. Значит, новый добавится под ID == 55
3. После всего этого переводим число (новый, следующий ID, в примере выше - 55) в 62-ичную систему счисления путём получения остатков от деления на 62 каждый раз.
4. Переворачиваем полученный массив остатков наоборот и по ключам, соответствующим числам в ревёрснутом массиве, находим буквы для кода.

После полученный от алгоритма адрес добавляется в базу данных. Всё, теперь можно использовать данную ссылку в Redirect.

### /custom

Берём структуру с адресом исходным и придуманным нами из командной строки, расшифровываем её с помощью создания Decoder'а и проверяем, правильно ли расшифровались данные. Затем начинаем процедуру добавления адреса к базе данных.

То же самое, что и с [`/decode`], но сокращёенная ссылка придумана нами, а не сделана с помощью base62. Всё, теперь можно использовать данную ссылку в Redirect.

### Redirect

Поднимается сервер на порту 8080. Чтобы перейти по ссылке, в адресной строке браузера мы вводим  [`localhost:8080/*сокращённая-ссылка*`] (например, опять же [`localhost:8080/the-most-popular-search`]). Осуществляется переход по введённому адресу с последующим поиском PATH от данного URL. Находим в БД нужный адрес, берём из БД настоящую (исходную) ссылку и перенаправляем на неё.

Вот и всё описание работы программы.

## Усложнения

1. Добавлена валидация URL в функции validateURL. Сначала адрес парсится. Если он не имеет в своём составе SCHEME в виде [`http://`], то добавляем её. Парсим второй раз для окончательной проверки валидности. Адрес обязательно должен быть как минимум двухуровневый (домен верхнего и второго уровней), поэтому проверяем, чтобы точка в адресе была не в начале или в конце, а в середине. Также HOST не должен пустовать (адреса вроде [`src/RoFlURL`] не пройдут). Иначе паникуем => возникает ошибка и код ломается.
2. Добавлена возможность создавать кастомные адреса. Об этом было рассказано выше.
